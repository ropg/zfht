#!/bin/sh

USAGE="Usage: zfht [-d] [-a] [-t] [-z <zonesdir>] [-s <zonessubdir>] [file_patterns...]"

# Helper functions
_add_to() { eval "v=\${$1}"; ! _is_in "$v" "$2" && eval "$1=\"$v $2\""; }
_dbg() { [ "$DRY" ] && for _dbgline in "$@"; do echo "$_dbgline" >&1; done; }
_err() { printf "ERROR: "; for _errline in "$@"; do echo "$_errline" >&2; done; exit 1; }
_exec() { [ "$DRY" ] && echo "$@" || "$@"; }
_find_includers() {
    for file in $ALL_FILES; do
        grep -q "^\$INCLUDE[[:space:]]\+\"*$1\"*" "$file" && echo $file && _find_includers "$file"
    done
}
_find_includes() {
    for include in $(awk '/^\$INCLUDE[[:space:]]+"/ {gsub(/"/, "", $2); print $2}' "$1" 2>/dev/null); do
        [ "${include#/}" != "$include" ] && _err "Absolute include path $include not supported"
        [ ! -f "$include" ] && _err "Include file $include not found"
        echo "$include"
        _find_includes "$include"    #recurse
    done
}
_fix_files() { sed -e "s|^$ZONESDIR/||" -e 's|^\./||' | grep -v '.zfht/' | sort; }  # sort for determinism in -d output for tests
_is_in() { printf '%s\n' "$1" | tr ' \t' '\n' | grep -Fxq -- "$2"; }
_remove_from() { eval "$1=\"\$(echo \$$1 | sed -E 's|\b$2\b||g')\""; }
_run_script() {
    script="$ZONESSUBDIR/.zfht/$1"
    zonefile="$2"
    zone=$(basename "$zonefile"); zone=${zone%.zone}
    [ "$DRY" ] && echo "$script $zone $zonefile" && return 0
    [ ! -x "$script" ] && return 1
    $script "$zone" "$zonefile" || ERRORS=1
    return 0
}
_write_lastrun() {
    mkdir -p $(dirname $LASTRUN_FILE)
    echo $CURRENT_ZONEFILES > $LASTRUN_FILE
    echo "Stored state, next run will process changes from now on."
    return 0
}

# Depends on zfht-update-serial
which zfht-update-serial >/dev/null 2>&1 || _err "zfht-update-serial not found in PATH"

# Parse options
while [ $# -gt 0 ]; do
	case "$1" in
		-d) DRY=1; shift ;;
		-a) DO_ALL=1; shift ;;
        -w) WRITE_LASTRUN=1; shift ;;
        -t) TOUCH=1; shift ;;
        -z) ZONESDIR=$2; shift; shift ;;
        -s) ZONESSUBDIR=$2; shift; shift ;;
		-*) _err "Invalid option $1" "$USAGE" ;;
		*) break ;;
	esac
done

# Remaining arguments are file patterns
[ $# -gt 0 ] && FILEMODE=1

# Validate options
[ "$DO_ALL" ] && [ "$FILEMODE" ] && _err "-a option can only be used in timestamp mode"
[ "$WRITE_LASTRUN" ] && [ "$FILEMODE" ] && _err "-w option can only be used in timestamp mode"

# ZONESDIR and ZONESSUBDIR
[ ! "$ZONESDIR" ] && ZONESDIR=$(pwd)    # Defaults to current directory
[ ! -d "$ZONESDIR" ] && _err "ZONESDIR $ZONESDIR not found"
[ ! "$ZONESSUBDIR" ] && ZONESSUBDIR="."
ZONESSUBDIR="${ZONESSUBDIR#$ZONESDIR/}"  # Strip in case we got full path
[ ! -d "$ZONESDIR/$ZONESSUBDIR" ] && _err "ZONESSUBDIR $ZONESSUBDIR not found in $ZONESDIR"

# Name of file that stores list of zone files present at last run, mtime serves as timestamp
LASTRUN_FILE="$ZONESSUBDIR/.zfht/lastrun"

# Resolve file arguments to their paths relative to ZONESDIR
if [ "$FILEMODE" ]; then
    for file in "$@"; do
        [ ! -f "$file" ] && _err "File $file not found"
        # Get absolute path, then check if it's within ZONESDIR
        abs_file="$(cd "$(dirname "$file")" && pwd)/$(basename "$file")"
        case "$abs_file" in
            "$ZONESDIR"/*) RESOLVED_ARGS="$RESOLVED_ARGS ${abs_file#$ZONESDIR/}" ;;
            *) _err "File $file is not within $ZONESDIR" ;;
        esac
    done
    # Replace $@ with resolved args
    set -- $RESOLVED_ARGS
fi

# Everything now relative to ZONESDIR
cd "$ZONESDIR"

ALL_FILES="$(find $ZONESSUBDIR -type f 2>/dev/null | _fix_files)"

# Error if there are spaces in any file name
spaces="$(printf '%s\n' "$ALL_FILES" | grep ' ')"
[ "$spaces" ] && _err "Spaces in file names not supported:" "$spaces"

CURRENT_ZONEFILES=$(find $ZONESSUBDIR -maxdepth 1 -type f 2>/dev/null | _fix_files)
LASTRUN_ZONEFILES=$(cat $LASTRUN_FILE 2>/dev/null)

# -w: write lastrun file and exit
[ "$WRITE_LASTRUN" ] && _exec _write_lastrun && exit 0

# CHANGED
if [ "$FILEMODE" ]; then
    CHANGED="$@"
elif [ "$DO_ALL" ]; then
    CHANGED="$ALL_FILES"
elif [ -f "$LASTRUN_FILE" ]; then
    # Use file modification time on lastrun file to find changed files
    CHANGED=$(find $ZONESSUBDIR -type f -newer $LASTRUN_FILE 2>/dev/null | _fix_files)
else
    echo "No previous run information found. To initialize, use 'zfht -a'"
    echo "to process all files as if they just appeared, or 'zfht -w' to"
    echo "store state and only process subsequent changes on next run."
    exit 0
fi
_dbg "=== CHANGED FILES ===" ${CHANGED:-<none>} ""

# no need to trace includes if we're processing all files
if [ ! "$DO_ALL" ]; then
    # INCLUDERS: depend on changed files (recursive)
    for file in $CHANGED; do
        for includer in $(_find_includers "$file"); do
            ! _is_in CHANGED "$includer" && _add_to INCLUDERS "$includer"
        done
    done
    _dbg "=== INCLUDERS (include changed files, recursively) ===" ${INCLUDERS:-<none>} ""
    # INCLUDED: files any of the now indentified files include (recursive)
    for file in $CHANGED $INCLUDERS; do
        for included in $(_find_includes "$file"); do
            ! _is_in CHANGED "$included" && ! _is_in INCLUDERS "$included" && _add_to INCLUDED "$included"
        done
    done
    _dbg "=== INCLUDED FILES (by all above, recursively) ===" ${INCLUDED:-<none>} ""
fi

# timestamp mode: look for zone files added or removed since last run
if [ ! "$FILEMODE" ]; then
    for file in $CURRENT_ZONEFILES; do
        ! _is_in "$LASTRUN_ZONEFILES" "$file" && _add_to ADDED_ZONEFILES "$file"
    done
    _dbg "=== ADDED ZONEFILES ===" ${ADDED_ZONEFILES:-<none>} ""
    for zonefile in $LASTRUN_ZONEFILES; do
        ! _is_in "$CURRENT_ZONEFILES" "$zonefile" && _add_to DELETED_ZONEFILES "$zonefile"
    done
    _dbg "=== DELETED ZONEFILES ===" ${DELETED_ZONEFILES:-<none>} ""
fi

# AFFECTED: but not already in ADDED_ZONEFILES
for file in $CHANGED $INCLUDERS; do
    _is_in "$CURRENT_ZONEFILES" "$file" && ! _is_in "$ADDED_ZONEFILES" "$file" && _add_to AFFECTED_ZONEFILES "$file"
done
_dbg "=== AFFECTED ZONEFILES ===" ${AFFECTED_ZONEFILES:-<none>} ""

# So far was all about figuring things out. Only below this point are we modifying things.
_dbg "=== ACTIONS TAKEN (if this weren't a dry run) ==="

# update any SOA serial numbers in any of the affected files
for file in $CHANGED $INCLUDERS $INCLUDED; do
    _exec zfht-update-serial -q "$file" || ERRORS=1
done

# -t: touch files that depend on changed files
[ "$TOUCH" ] && for file in $INCLUDERS; do 
    if [ "$DRY" ]; then echo "touch $file"; else echo "Touched $file"; touch "$file"; fi;
done

# run any user-provided scripts
for zonefile in $ADDED_ZONEFILES; do
    _run_script addzone "$zonefile" || _run_script modzone "$zonefile"      # try modzone if addzone not found
done
for zonefile in $DELETED_ZONEFILES; do _run_script delzone "$zonefile"; done
for zonefile in $AFFECTED_ZONEFILES; do _run_script modzone "$zonefile"; done
[ "$ERRORS" ] && _err "Script(s) failed, lastrun file not updated." "(Everything will be tried again next time.)"

# write lastrun file in timestamp mode
[ ! "$FILEMODE" ] && _exec _write_lastrun
